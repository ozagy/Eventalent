<!DOCTYPE html>
<!-- saved from url=(0076)http://threejsdoc.appspot.com/doc/three.js/examples/canvas_lines_sphere.html -->
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Eventalent - Event</title>
		<%= javascript_include_tag "application" %>
  		<%= javascript_include_tag "facebook" %>
  		<%= javascript_include_tag "Three.js" %>
  		<%= javascript_include_tag "Detector.js" %>
		<%= javascript_include_tag "RequestAnimationFrame.js" %>
		<%= javascript_include_tag "Stats.js" %>
		<%= javascript_include_tag "OrbitControls.js" %>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			a {
				color:#0078ff;
			}
		</style>
	</head>
	<body>
		<script>
		function refresh_fb(){
		    <% if @error %> 
		      FB.login(function(response) {
		        if (response.authResponse) {
		          window.location = '/auth/facebook/callback';
		        }
		      },{scope: 'user_friends,user_events,friends_events'});
		    <% end %>
	    }
    	</script>
		
		

		<script>

			var SCREEN_WIDTH = window.innerWidth,
			SCREEN_HEIGHT = window.innerHeight,

			mouseX = 0, mouseY = 0,

			windowHalfX = window.innerWidth / 2,
			windowHalfY = window.innerHeight / 2,

			SEPARATION = 200,
			AMOUNTX = 10,
			AMOUNTY = 10,

			camera, scene, renderer, controls, stats;
			var canvas1, texture1, sprite1, context1;
			var projector, INTERSECTED;

			init();
			animate();

			function init() {

				var container, separation = 100, amountX = 50, amountY = 50,
				particles, particle;

				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				if ( Detector.webgl )
					renderer = new THREE.WebGLRenderer( {antialias:true} );
				else
					renderer = new THREE.CanvasRenderer(); 
				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.bottom = '0px';
				stats.domElement.style.zIndex = 100;
				
				container.appendChild(renderer.domElement);
				
				// LIGHT
				var light = new THREE.PointLight(0xffffff);
				light.position.set(0,500,0);
				scene.add(light);
				// particles

				// var PI2 = Math.PI * 2;
				// var material = new THREE.ParticleCanvasMaterial( {
// 
					// color: 0xffffff,
					// program: function ( context ) {
// 
						// context.beginPath();
						// context.arc( 0, 0, 1, 0, PI2, true );
						// context.closePath();
						// context.fill();
// 
					// }
// 
				// } );
// 				
				// var geometry = new THREE.Geometry();
// 
				// for ( i = 0; i < 1000; i ++ ) {
// 
					// var vertex = new THREE.Vector3();
					// vertex.x = Math.random() * 2000 - 1000;
					// vertex.y = Math.random() * 2000 - 1000;
					// vertex.z = Math.random() * 2000 - 1000;
// 
					// geometry.vertices.push( vertex );
// 
				// }
				// particle = new THREE.ParticleSystem( geometry, material );
				// scene.add( particle );

				// lines
				var vector = {};
				var vector2 = {};
				var geometry = {}
				var line = {};
				<% @connections.each do |c| %>
					geometry = new THREE.Geometry();

					vector = new THREE.Vector3( <%= @pos[c[:uid1]][:x]%>, <%= @pos[c[:uid1]][:y]%>, <%= @pos[c[:uid1]][:z]%> );
					geometry.vertices.push( vector );

					vector2 = new THREE.Vector3( <%= @pos[c[:uid2]][:x]%>, <%= @pos[c[:uid2]][:y]%>, <%= @pos[c[:uid2]][:z]%> );
					geometry.vertices.push( vector2 );

					line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff,transparent: true, opacity: Math.random()*0.1+0.1 } ) );
					scene.add( line );
				<% end %>
				// sphere
				var sphere = {}
				spheres = [];
				var spriteMaterial = {}
				var uid = 0;
				canvas = {};
				context = {};
				texture = {};
				sprite = {};
				
				<% @members.each do |m| %>
				  sphere = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff,side: THREE.BackSide,transparent: true, opacity: 0.6 }));
			      sphere.position.x = <%= @pos[m['uid']][:x] %>
			      sphere.position.y = <%= @pos[m['uid']][:y] %>
			      sphere.position.z = <%= @pos[m['uid']][:z] %>
			      sphere.name = '<%= m['name'] %>';
			      spheres.push(sphere);
			      scene.add(sphere);
			      
			      var uid =<%= m['uid'] %>;
					// create a canvas element
			      canvas[uid] = document.createElement('canvas');
				  context[uid] = canvas[uid].getContext('2d');
				  context[uid].font = "Bold 20px Arial";
				  
				  var message = '<%= m['name'] %>';
				  var metrics = context[uid].measureText(message);
				  var width = metrics.width;
				  context[uid].fillStyle = "rgba(255,255,255,0.65)"; // text color
				  context[uid].fillText( message, 0,20 );
				    
					// canvas contents will be used for a texture
					texture[uid] = new THREE.Texture(canvas[uid]) 
					texture[uid].needsUpdate = true;
					
					////////////////////////////////////////
					
					spriteMaterial = new THREE.SpriteMaterial( { map: texture[uid], useScreenCoordinates: true, alignment: THREE.SpriteAlignment.topLeft } );
					sprite[uid] = new THREE.Sprite( spriteMaterial );
					sprite[uid].scale.set(200,100,1);
					pos_2d = toScreenXY(sphere.position, camera);
					sprite[uid].position.set( pos_2d.x, pos_2d.y, 0 );
					sprite[uid].sphere = sphere;
					scene.add( sprite[uid] );	
				
					//////////////////////////////////////////
			    <% end %>
			    
			    projector = new THREE.Projector();
			    /////// draw text on canvas /////////

				// create a canvas element
				canvas1 = document.createElement('canvas');
				context1 = canvas1.getContext('2d');
				context1.font = "Bold 20px Arial";
				context1.fillStyle = "rgba(255,255,255,0.95)";
			    context1.fillText('Hello, world!', 0, 20);
			    
				// canvas contents will be used for a texture
				texture1 = new THREE.Texture(canvas1) 
				texture1.needsUpdate = true;
				
				////////////////////////////////////////
				
				var spriteMaterial = new THREE.SpriteMaterial( { map: texture1, useScreenCoordinates: true, alignment: THREE.SpriteAlignment.topLeft } );
				
				sprite1 = new THREE.Sprite( spriteMaterial );
				sprite1.scale.set(200,100,1.0);
				sprite1.position.set( 50, 50, 0 );
				scene.add( sprite1 );	
			
				//////////////////////////////////////////
				
				

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				document.addEventListener("mousedown", onDocumentmouseClick, false);
			}

			//

			function onDocumentMouseMove(event) {
				
				sprite1.position.set( event.clientX + 10 , event.clientY - 20, 0 );

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length > 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}
			function onDocumentmouseClick( event ){

				var vector = new THREE.Vector3( (event.clientX/SCREEN_WIDTH) * 2 - 1, -(event.clientY/SCREEN_HEIGHT) * 2 + 1, 1 );
				projector.unprojectVector( vector, camera );
				var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
			    
				// create an array containing all objects in the scene with which the ray intersects
				var intersects = ray.intersectObjects( spheres );
				console.log(intersects[0].object);
			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();
				update();

			}
			
			function update(){

				for ( var key in sprite ){
					sphere_p = sprite[key].sphere.position;
					var pos_2d = toScreenXY( sphere_p, camera );
					sprite[key].position.set( pos_2d.x + 10, pos_2d.y - 10, 0 );
				}
				// create a Ray with origin at the mouse position
				var vector = new THREE.Vector3( ((mouseX+windowHalfX)/SCREEN_WIDTH) * 2 - 1, -((mouseY+windowHalfY)/SCREEN_HEIGHT) * 2 + 1, 1 );
				projector.unprojectVector( vector, camera );
				var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
			    
				// create an array containing all objects in the scene with which the ray intersects
				var intersects = ray.intersectObjects( spheres );
			
				// INTERSECTED = the object in the scene currently closest to the camera 
				//		and intersected by the Ray projected from the mouse position 	
				
				// if there is one (or more) intersections
				if ( intersects.length > 0 )
				{
					// if the closest object intersected is not the currently stored intersection object
					if ( intersects[ 0 ].object != INTERSECTED ) 
					{
					    // restore previous intersection object (if it exists) to its original color
						if ( INTERSECTED ) 
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						// store reference to closest object as current intersection object
						INTERSECTED = intersects[ 0 ].object;
						// store color of closest object (for later restoration)
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
						// set a new color for closest object
						INTERSECTED.material.color.setHex( 0x0090ff );
						INTERSECTED.scale.set( 2, 2, 2 );
						// update text, if it has a "name" field.
						if ( intersects[ 0 ].object.name )
						{
							//intersects[ 0 ].object.material.
						    context1.clearRect(0,0,640,480);
							var message = intersects[ 0 ].object.name;
							var metrics = context1.measureText(message);
							var width = metrics.width;
							context1.fillStyle = "rgba(255,255,255,0.95)"; // black border
							context1.fillRect( 0,0, width+16,20+10);
							context1.fillStyle = "rgba(0,85,150,1)"; // text color
							context1.fillText( message, 8,22 );
							texture1.needsUpdate = true;
						}
						
					}
				} 
				else // there are no intersections
				{
					// restore previous intersection object (if it exists) to its original color
					if ( INTERSECTED ) {
						INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						INTERSECTED.scale.set( 0.5, 0.5, 0.5 );
					}
					// remove previous intersection object reference
					//     by setting current intersection object to "nothing"
					INTERSECTED = null;
					context1.clearRect(0,0,300,300);
					texture1.needsUpdate = true;
				}

				controls.update();
				stats.update();
			}

			function render() {

				renderer.render( scene, camera );

			}
			
			function toScreenXY( position, camera ) {
	            var pos = position.clone();
	            projScreenMat = new THREE.Matrix4();
	            projScreenMat.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
	            pos.applyProjection( projScreenMat );
	            
	            //var div = document.getElementById('my_canvas');
	
	            return { x: ( pos.x + 1 ) * SCREEN_WIDTH/2,
	                 y: ( - pos.y + 1) * SCREEN_HEIGHT/2 };

        	}

		</script><div><canvas id='my_canvas' width="1330" height="802"></canvas></div>

	</body>
</html>
